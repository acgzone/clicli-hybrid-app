{"version":3,"sources":["node_modules/fre/dist/fre.js","index.js"],"names":["DOWN_URL","QCODE","App","document","getElementById"],"mappings":"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","file":"dev.0d6f4e86.js","sourceRoot":"..","sourcesContent":["/**\n * by 132yse Copyright 2019-04-23\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.fre = {}));\n}(this, function (exports) { 'use strict';\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n    while (length-- > 2) rest.push(arguments[length]);\n    while (rest.length) {\n      let node = rest.pop();\n      if (node && node.pop) {\n        for (length = node.length; length--;) rest.push(node[length]);\n      } else if (node === null || node === true || node === false) ; else {\n        children.push(\n          typeof node !== 'object' ? { type: 'text', nodeValue: node } : node\n        );\n      }\n    }\n    return { type, props: { ...props, children }}\n  }\n\n  const defer =\n    typeof Promise === 'function' ? cb => Promise.resolve().then(cb) : setTimeout;\n  const arrayfy = array =>\n    !array ? [] : Array.isArray(array) ? array : [array];\n  const isNew = (prev, next) => key => prev[key] !== next[key];\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'children' || name === 'key') ; else if (name === 'style') {\n      Object.keys(newValue).forEach(key => {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      });\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps))\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n  let oldInputs = [];\n  function update (key, reducer, value) {\n    const current = this ? this : getCurrentInstance();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor () {\n    cursor = 0;\n  }\n  function useState (initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer (reducer, initState) {\n    let current = getCurrentInstance();\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    if (!current) {\n      return [initState, setter]\n    } else {\n      cursor++;\n      let state = current.state;\n      if (typeof state === 'object' && key in state) {\n        return [state[key], setter]\n      } else {\n        current.state[key] = initState;\n      }\n      let value = initState;\n      return [value, setter]\n    }\n  }\n  function useEffect (effect, inputs) {\n    let current = getCurrentInstance();\n    if (current) {\n      let key = '$' + cursor;\n      current.effects[key] = useMemo(effect, inputs);\n      cursor++;\n    }\n  }\n  function useMemo (create, inputs) {\n    return function () {\n      let current = getCurrentInstance();\n      if (current) {\n        let hasChaged = inputs\n          ? oldInputs.some((value, i) => inputs[i] !== value)\n          : true;\n        if (hasChaged) {\n          create();\n        }\n        oldInputs = inputs;\n      }\n    }\n  }\n  function createContext (initContext = {}) {\n    let context = initContext;\n    let setters = [];\n    const update = newContext => setters.forEach(fn => fn(newContext));\n    const subscribe = fn => setters.push(fn);\n    const unSubscribe = fn => (setters = setters.filter(f => f !== fn));\n    return { context, update, subscribe, unSubscribe }\n  }\n  function useContext (ctx) {\n    const [context, setContext] = useState(ctx.context);\n    ctx.subscribe(setContext);\n    useEffect(() => ctx.unSubscribe(setContext));\n    return [context, ctx.update]\n  }\n\n  const [HOST, HOOK, ROOT, PLACE, DELETE, UPDATE] = [\n    'host',\n    'hook',\n    'root',\n    'place',\n    'delete',\n    'update'\n  ];\n  let updateQueue = [];\n  let nextWork = null;\n  let pendingCommit = null;\n  let currentInstance = null;\n  function render (vdom, container) {\n    updateQueue.push({\n      tag: ROOT,\n      base: container,\n      props: { children: vdom }\n    });\n    defer(workLoop);\n  }\n  function scheduleWork (instance) {\n    updateQueue.push({\n      tag: HOOK,\n      instance,\n      state: instance.state\n    });\n    defer(workLoop);\n  }\n  function workLoop () {\n    if (!nextWork && updateQueue.length) {\n      resetWork();\n    }\n    while (nextWork) {\n      nextWork = performWork(nextWork);\n    }\n    if (pendingCommit) {\n      commitAllWork(pendingCommit);\n    }\n  }\n  function resetWork () {\n    const update = updateQueue.shift();\n    if (!update) return\n    if (update.state) {\n      update.instance.fiber.state = update.state;\n    }\n    const root =\n      update.tag == ROOT ? update.base.rootFiber : getRoot(update.instance.fiber);\n    nextWork = {\n      tag: ROOT,\n      base: update.base || root.base,\n      props: update.props || root.props,\n      alternate: root\n    };\n  }\n  function performWork (WIP) {\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\n    if (WIP.child) {\n      return WIP.child\n    }\n    let wip = WIP;\n    while (wip) {\n      completeWork(wip);\n      if (wip.sibling) return wip.sibling\n      wip = wip.parent;\n    }\n  }\n  function updateHost (WIP) {\n    if (!WIP.base) WIP.base = createElement(WIP);\n    const newChildren = WIP.props.children;\n    reconcileChildren(WIP, newChildren);\n  }\n  function updateHOOK (WIP) {\n    let instance = WIP.base;\n    if (instance == null) {\n      instance = WIP.base = createInstance(WIP);\n    } else if (WIP.props == WIP.props && !WIP.state) {\n      cloneChildFibers(WIP);\n    }\n    instance.props = WIP.props || {};\n    instance.state = WIP.state || {};\n    instance.effects = WIP.effects || {};\n    currentInstance = instance;\n    resetCursor();\n    const newChildren = WIP.type(WIP.props);\n    reconcileChildren(WIP, newChildren);\n  }\n  function reconcileChildren (WIP, newChildren) {\n    newChildren = arrayfy(newChildren);\n    let oldFiber = WIP.alternate ? WIP.alternate.child : null;\n    let newFiber = null;\n    let n = 0;\n    while (n < newChildren.length || oldFiber != null) {\n      const child = newChildren[n];\n      const prevFiber = newFiber;\n      const sameType = oldFiber && child && child.type == oldFiber.type;\n      if (sameType) {\n        newFiber = {\n          tag: oldFiber.tag,\n          base: oldFiber.base,\n          parent: WIP,\n          alternate: oldFiber,\n          patchTag: UPDATE,\n          type: oldFiber.type,\n          props: child.props || { nodeValue: child.nodeValue },\n          state: oldFiber.state\n        };\n      }\n      if (child && !sameType) {\n        newFiber = {\n          tag: typeof child.type === 'string' ? HOST : HOOK,\n          type: child.type,\n          props: child.props || { nodeValue: child.nodeValue },\n          parent: WIP,\n          patchTag: PLACE\n        };\n      }\n      if (oldFiber && !sameType) {\n        oldFiber.patchTag = DELETE;\n        WIP.patches = WIP.patches || [];\n        WIP.patches.push(oldFiber);\n      }\n      if (oldFiber) oldFiber = oldFiber.sibling;\n      if (n == 0) {\n        WIP.child = newFiber;\n      } else if (prevFiber && child) {\n        prevFiber.sibling = newFiber;\n      }\n      n++;\n    }\n  }\n  function createInstance (fiber) {\n    const instance = new fiber.type(fiber.props);\n    instance.fiber = fiber;\n    return instance\n  }\n  function cloneChildFibers (parentFiber) {\n    const oldFiber = parentFiber.alternate;\n    if (!oldFiber.child) return\n    let oldChild = oldFiber.child;\n    let prevChild = null;\n    while (oldChild) {\n      const newChild = {\n        type: oldChild.type,\n        tag: oldChild.tag,\n        base: oldChild.base,\n        props: oldChild.props,\n        state: oldChild.state,\n        alternate: oldChild,\n        parent: parentFiber\n      };\n      if (prevChild) {\n        prevChild.sibling = newChild;\n      } else {\n        parentFiber.child = newChild;\n      }\n      prevChild = newChild;\n      oldChild = oldChild.sibling;\n    }\n  }\n  function completeWork (fiber) {\n    if (fiber.tag == HOOK) {\n      fiber.base.fiber = fiber;\n    }\n    if (fiber.parent) {\n      const childPatches = fiber.patches || [];\n      const selfPatch = fiber.patchTag ? [fiber] : [];\n      const parentPatches = fiber.parent.patches || [];\n      fiber.parent.patches = parentPatches.concat(childPatches, selfPatch);\n    } else {\n      pendingCommit = fiber;\n    }\n  }\n  function commitAllWork (WIP) {\n    WIP.patches.forEach(f => commitWork(f));\n    commitEffects(currentInstance.effects);\n    WIP.base.rootFiber = WIP;\n    nextWork = null;\n    pendingCommit = null;\n  }\n  function commitWork (fiber) {\n    if (fiber.tag == ROOT) return\n    let parentFiber = fiber.parent;\n    while (parentFiber.tag == HOOK) {\n      parentFiber = parentFiber.parent;\n    }\n    const parentNode = parentFiber.base;\n    if (fiber.patchTag == PLACE && fiber.tag == HOST) {\n      parentNode.appendChild(fiber.base);\n    } else if (fiber.patchTag == UPDATE && fiber.tag == HOST) {\n      updateElement(fiber.base, fiber.alternate.props, fiber.props);\n    } else if (fiber.patchTag == DELETE) {\n      commitDELETE(fiber, parentNode);\n    }\n  }\n  function commitDELETE (fiber, domParent) {\n    let node = fiber;\n    while (true) {\n      if (node.tag == HOOK) {\n        node = node.child;\n        continue\n      }\n      domParent.removeChild(node.base);\n      while (node != fiber && !node.sibling) {\n        node = node.parent;\n      }\n      if (node == fiber) {\n        return\n      }\n      node = node.sibling;\n    }\n  }\n  function getRoot (fiber) {\n    let node = fiber;\n    while (node.parent) {\n      node = node.parent;\n    }\n    return node\n  }\n  function getCurrentInstance () {\n    return currentInstance || null\n  }\n  function commitEffects (effects) {\n    Object.keys(effects).forEach(key => {\n      let effect = effects[key];\n      effect();\n    });\n  }\n\n  exports.h = h;\n  exports.render = render;\n  exports.useState = useState;\n  exports.useReducer = useReducer;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.createContext = createContext;\n  exports.useContext = useContext;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","import './style.css'\r\nimport { h, render } from 'fre'\r\n\r\nconst DOWN_URL = 'https://cdn.jsdelivr.net/npm/@clicli/app@latest'\r\nconst QCODE =\r\n  'https://0d077ef9e74d8.cdn.sohucs.com/roUjdPS_jpg'\r\n\r\nfunction App () {\r\n  return (\r\n    <div class='main'>\r\n      <div class=\"left\">\r\n      <div class='logo' />\r\n      <h1>人·生·就·是·佛</h1>\r\n      <ul class='link'>\r\n        <a href={DOWN_URL} target='_blank'>\r\n          <li>Android</li>\r\n        </a>\r\n        <a href=''>\r\n          <li>IOS</li>\r\n        </a>\r\n      </ul>\r\n      <div class='qcode'>\r\n        <img src={QCODE} alt='c站 app' />\r\n      </div>\r\n      </div>\r\n      <div class=\"right\"></div>\r\n    </div>\r\n  )\r\n}\r\n\r\nrender(<App />, document.getElementById('root'))\r\n"]}